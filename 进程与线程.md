# 操作系统关于I/O理解

## 从CPU开始说起：

- 寄存器：存储信息的最小单位；
- 指令集：告诉CPU可以执行什么命令，需要提供什么样的操作
  - 从内存中读取数据
  - 对两个数据进行操作
  - 检查数据……
- 时钟信号：CPU主频，每个时钟信号完成一个基础操作，多个操作组成一个指令
- CPU功能总结：
  - 从内存中取出指令
  - 执行指令，回到上一步
- 取出指令的位置：Program Counter（PC寄存器）——一个存取更快的寄存器，将main作为入口
- 指令从哪里来？——从源文件经过编译器生成可执行文件，将可执行文件放入到磁盘中，此时的可执行文件已经是机器指令了，磁盘中的机器指令放入到内存中，被CPU逐个执行
- 所以指令就是我们定义的函数经过编译器生成的，需要CPU执行的函数就是将经过编译的机器指令放入PC寄存器

## 从CPU到进程：

- 没有操作系统的情况下如何让CPU执行程序？
  - 在内存中找到一块大小合适的区域（PC）装入程序；
  - 找到函数的入口，设置好PC寄存器让CPU开始执行程序；

- 机器指令需要加载到内存中执行，需要记录下内存的起始地址和长度，因此需要类似以下的的数据结构（进程）

  ```C++
  struct dataStruct {
      void* startAddr;
      int len;
      
      void* startPointer;
  };
  //该数据结构表明起始位置和长度作为CPU执行的PC寄存器
  ```

- 总结起来进程就是一个模拟CPU执行的过程，规划出一块区域来作为PC寄存器，从进程的起始指针开始执行，这个起始指针就叫做main()函数
- 进程是程序执行的最小单位

## 从进程到线程：

- 进程的本质就是内存当中的一个特殊区域，保存CPU执行机器指令以及运行时的堆栈信息，进程运行就将main()函数的第一条机器指令地址写入PC寄存器，进程就开始运行；进程的缺点在于只有一个main入口函数，因此进程中的机器指令只能被一个CPU执行，为了让多个CPU来执行同一个进程中机器指令就可以考虑将PC寄存器指向多个函数，由此引出线程的概念

- main函数的特点在于是CPU执行的第一个函数，因此当PC寄存器指向非main函数时就创建了一个线程，由此，同一个进程中的机器指令可以被多个CPU同时执行，即一个进程中有多个执行流

- 高性能、高并发的本质在于创建出数量合适的线程即可，

- 线程与内存：

  - 函数在执行时产生的数据包括函数参数、局部变量、返回地址，这些数据保存在栈中，栈底就是进程的入口函数
  - 有了线程后，进程存在多个执行入口，存在多个执行流，即操作系统要为每个线程在进程的地址空间中分配一个栈
  - 创建进程是需要内存空间的

- 线程的使用：

  - 线程任务分类：长任务、短任务
  - 长任务通常伴随着一个软件的启动和关闭
  - 短任务一般是一次请求、查询等
  - 短任务的特点在于：处理任务所需时间短、任务数量大，如果频繁创建进程来进行任务比较浪费系统资源，则引出线程池，先创建一定数量的线程，有任务时交给线程处理（思想是：可控、复用）

- 线程池的工作：

  - 问题模型：生产者-消费者问题（如何在任务队列空时不消费，如何在任务队列满时不加任务）

  - 线程池任务：需要处理的数据+处理数据的函数

  - 伪代码：

    ```C++
    struct task{
        void* data;
        handler handler;
    }
    while (true){
        struct task = GetFromQueue();
        task->handle(task->data);
    }
    ```

- 线程池的数量：

  - CPU密集型
  - I/O密集型：N*(1 + WT/ CT)

## 执行I/O操作时的底层：

- 什么是I/O操作：内存与外部设备之间的数据copy就是I/O
- I/O带来的问题：IO的速度远远慢于CPU处理数据的速度，每次CPU要是等待IO处理速度就会被拉的和IO一样低，因此出现了阻塞（阻塞=暂停需要IO的工作，进行其他的工作，其他工作做完之后再切换回来）
- 模拟一下阻塞过程
  - 进程A进行到了一段需要读取文件的代码，比如常用的read函数，操作系统检测到IO设备请求后暂停进程A的运行（记录当前进程的运行状态并且把CPU的PC寄存器指向其他的指令，默认下一个）
  - 操作系统保存完前一个暂停状态之后，将进程Apush到阻塞队列中，不同的操作系统会有不同的实现，可能每个IO设备都有对应的阻塞队列
  - 同时，操作系统向硬盘发送IO请求，drive开始将磁盘中的数据copy到进程A的buf中，尽管A已经暂停，但是可以向其内存中写入数据；此时操作系统运行进程B
  - 当copy操作完成并给进程B结束之后恢复A的状态，继续执行A的指令，从阻塞队列中取出A的状态，加入到就绪队列进行



## 讨论同步与异步

- 同步指的是当funcA调用funcB的时候，A后续代码都不会执行，直到B执行结束，相当于队列，前一个不走就轮不到你，一般函数调用都是同步
- 异步一般伴随IO操作比较耗时的任务（文件读写、网络数据收发），即使文件没有读取完成，也能够立即返回，调用方不会被阻塞，程序和IO可以同时进行
  - 调用方不关心执行结果
  - 调用方需要知道执行结果
    - 通知机制：执行完成后发送信号通知调用方任务完成
    - 回调（callback）：将后续的步骤封装到函数中，将该函数一并作为参数传递

## IO多路复用

- 文件概念：将所有文件都抽象成一类，使用一套接口就能够实现所有的IO操作
  - open
  - seek
  - read write
  - close
- 文件描述符：使用一个数字来标识该文件，通过文件描述符表来查找对应的文件
  - 在Unix或者类Unix系统中，每一个进程都有一个文件描述符表，用来记录该进程打开的文件或者其他IO对象的信息
  - 当文件被打开时，操作系统会给这个文件分配一个文件描述符，并且将其保存在表中，通过该描述符来操作该文件

- 高并发：采用多线程，为每个IO操作请求开启一个线程，线程阻塞不会影响到其他进程，每个线程处理一个文件描述符
- 针对这个方法会有IO是否可读判断导致的阻塞，解决该问题的方法是通过IO接口主动向内核查询fd是否已经就绪
  - 场景：此时有1w个文件描述符，内核监视这个1w个文件描述符，如果有能够读写的文件描述符已经准备好了就交给线程处理
  - 该方法就是内核监视大量文件描述符，每一次内核找到能够处理的fd才交给线程处理，线程池一直都是就绪状态，对不同的IO接口都统一交给内核判断，线程只需要运行指令（IO多路复用）
- IO多路复用的基础是使用文件描述符来代表文件，统一了操作流程，并交给内核来判断是否读写完成，在交给线程来处理，使得线程池一直保持工作状态
- 过程描述：
  1. 拿到了一堆文件描述符，不论是什么类型的
  2. 通过调用某个函数告诉内核：这个函数先不要返回，监视，当这些文件描述符中有可以进行IO操作的时候再返回
  3. 当函数返回的时候就知道哪些文件描述符能够进行IO操作了
- 三种IO复用机制：
  - select：将需要监控的文件描述集通过函数参数形式告诉select，select将这些文件描述符集合拷贝到内核中，Linux规定用户监控的文件描述符集合不能超过1024个，并且只知道有fd满足可读写的要求，但是不知道是哪一个
  - poll：解决了select不能超过1024个的限制
  - epoll：引入epoll_ctl只操作有变化的文件描述符，和内核共享一块内存，减少了拷贝文件描述符的开销

